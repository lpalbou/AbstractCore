#!/usr/bin/env python3
"""
Diagnostic Tool: Analyze Dependency Graphs from BasicDeepResearcherB

This script helps visualize and diagnose circular dependency issues
in research plans generated by the LLM.
"""

import json
import sys
from collections import defaultdict, deque
from typing import Dict, List, Set, Tuple

def detect_cycles(dependencies: Dict[str, List[str]]) -> List[List[str]]:
    """
    Detect cycles in dependency graph using DFS

    Args:
        dependencies: Dict mapping question_id to list of dependency question_ids

    Returns:
        List of cycles found (each cycle is a list of question IDs)
    """
    cycles = []
    visited = set()
    rec_stack = set()

    def dfs(node: str, path: List[str]):
        """DFS to detect cycles"""
        visited.add(node)
        rec_stack.add(node)
        path.append(node)

        for neighbor in dependencies.get(node, []):
            if neighbor not in visited:
                dfs(neighbor, path.copy())
            elif neighbor in rec_stack:
                # Found a cycle
                cycle_start = path.index(neighbor)
                cycle = path[cycle_start:] + [neighbor]
                cycles.append(cycle)

        rec_stack.remove(node)

    # Start DFS from each node
    all_nodes = set(dependencies.keys())
    for dep_list in dependencies.values():
        all_nodes.update(dep_list)

    for node in all_nodes:
        if node not in visited:
            dfs(node, [])

    return cycles


def topological_sort_simulation(dependencies: Dict[str, List[str]], priorities: Dict[str, int]) -> Tuple[List[str], List[str]]:
    """
    Simulate the topological sort execution used by BasicDeepResearcherB

    Args:
        dependencies: Question dependencies
        priorities: Question priorities

    Returns:
        (execution_order, deadlocked_questions)
    """
    completed = set()
    remaining = set(dependencies.keys())
    execution_order = []

    iterations = 0
    max_iterations = len(remaining) + 1

    while remaining and iterations < max_iterations:
        iterations += 1

        # Find questions with satisfied dependencies
        ready = []
        for q_id in remaining:
            if all(dep in completed for dep in dependencies.get(q_id, [])):
                ready.append(q_id)

        if not ready:
            # Deadlock detected
            print(f"\nâš ï¸  DEADLOCK at iteration {iterations}")
            print(f"   Remaining questions: {len(remaining)}")
            print(f"   Completed questions: {len(completed)}")
            return execution_order, list(remaining)

        # Sort by priority
        ready.sort(key=lambda qid: priorities.get(qid, 2))

        # Process ready questions
        for q_id in ready:
            execution_order.append(q_id)
            completed.add(q_id)
            remaining.remove(q_id)

    return execution_order, []


def visualize_dependency_graph(
    questions: Dict[str, str],
    dependencies: Dict[str, List[str]],
    priorities: Dict[str, int],
    cycles: List[List[str]]
):
    """Print a visual representation of the dependency graph"""
    print("\n" + "="*80)
    print("DEPENDENCY GRAPH VISUALIZATION")
    print("="*80)

    print("\nðŸ“Š Questions:")
    for q_id in sorted(questions.keys()):
        priority_emoji = "ðŸ”´" if priorities.get(q_id, 2) == 1 else "ðŸŸ¡" if priorities.get(q_id, 2) == 2 else "ðŸŸ¢"
        print(f"  {priority_emoji} {q_id}: {questions[q_id][:60]}...")
        deps = dependencies.get(q_id, [])
        if deps:
            print(f"     â†³ Depends on: {', '.join(deps)}")

    print("\nðŸ”„ Cycles Detected:")
    if cycles:
        for i, cycle in enumerate(cycles, 1):
            print(f"  {i}. {' â†’ '.join(cycle)}")
    else:
        print("  âœ… No cycles detected")

    print("\nðŸ“ˆ Dependency Statistics:")
    total_deps = sum(len(deps) for deps in dependencies.values())
    avg_deps = total_deps / len(dependencies) if dependencies else 0
    max_deps = max((len(deps) for deps in dependencies.values()), default=0)

    print(f"  Total questions: {len(questions)}")
    print(f"  Total dependencies: {total_deps}")
    print(f"  Average dependencies per question: {avg_deps:.1f}")
    print(f"  Max dependencies for a question: {max_deps}")

    # Find questions with no dependencies
    independent = [q for q, deps in dependencies.items() if not deps]
    print(f"  Independent questions: {len(independent)}")

    # Find questions that nothing depends on (leaf nodes)
    all_deps = set()
    for deps in dependencies.values():
        all_deps.update(deps)
    leaf_nodes = [q for q in questions.keys() if q not in all_deps]
    print(f"  Leaf questions (nothing depends on them): {len(leaf_nodes)}")

    return independent, leaf_nodes  # Return for use in analyze_research_plan


def analyze_research_plan(plan_data: Dict):
    """Analyze a research plan for dependency issues"""
    # Extract questions and dependencies
    questions = {}
    priorities = {}
    dependencies = {}

    for q_data in plan_data.get('atomic_questions', []):
        q_id = q_data.get('id', f"q_{len(questions)}")
        questions[q_id] = q_data.get('question', 'Unknown')
        priorities[q_id] = q_data.get('priority', 2)

    dependencies = plan_data.get('dependencies', {})

    # Ensure all question IDs are in dependencies dict
    for q_id in questions.keys():
        if q_id not in dependencies:
            dependencies[q_id] = []

    # Detect cycles
    cycles = detect_cycles(dependencies)

    # Visualize
    independent, leaf_nodes = visualize_dependency_graph(questions, dependencies, priorities, cycles)

    # Simulate execution
    print("\n" + "="*80)
    print("EXECUTION SIMULATION")
    print("="*80)

    execution_order, deadlocked = topological_sort_simulation(dependencies, priorities)

    if deadlocked:
        print(f"\nâŒ DEADLOCK DETECTED!")
        print(f"   Successfully executed: {len(execution_order)} questions")
        print(f"   Deadlocked: {len(deadlocked)} questions")
        print(f"\n   Deadlocked questions:")
        for q_id in deadlocked:
            print(f"     â€¢ {q_id}: {questions[q_id][:60]}...")
            deps = dependencies.get(q_id, [])
            print(f"       Waiting for: {', '.join(deps)}")
    else:
        print(f"\nâœ… All {len(execution_order)} questions can be executed")
        print(f"\n   Execution order:")
        for i, q_id in enumerate(execution_order, 1):
            priority_emoji = "ðŸ”´" if priorities.get(q_id, 2) == 1 else "ðŸŸ¡" if priorities.get(q_id, 2) == 2 else "ðŸŸ¢"
            print(f"     {i:2d}. {priority_emoji} {q_id}: {questions[q_id][:60]}...")

    # Recommendations
    print("\n" + "="*80)
    print("RECOMMENDATIONS")
    print("="*80)

    if cycles:
        print("\nâš ï¸  CIRCULAR DEPENDENCIES DETECTED")
        print("\n   Recommended fixes:")
        print("   1. Remove one edge from each cycle")
        print("   2. Suggested edges to remove:")
        for cycle in cycles:
            # Suggest removing the edge from lowest priority to highest
            if len(cycle) > 1:
                # Remove edge from last to first in cycle
                print(f"      â€¢ Remove: {cycle[-2]} â†’ {cycle[-1]}")
    else:
        print("\nâœ… No circular dependencies")

    if len(independent) < len(questions) * 0.3:
        print(f"\nðŸ’¡ Only {len(independent)} independent questions ({len(independent)/len(questions)*100:.0f}%)")
        print("   Consider reducing dependencies for more parallel execution")


def main():
    """Main diagnostic function"""
    print("="*80)
    print("BasicDeepResearcherB Dependency Diagnostic Tool")
    print("="*80)

    # Example 1: Valid dependency graph
    print("\n\nðŸ§ª Example 1: VALID Dependency Graph")
    valid_plan = {
        "atomic_questions": [
            {"id": "q1", "question": "What is the basic definition?", "priority": 1},
            {"id": "q2", "question": "What are the key components?", "priority": 1},
            {"id": "q3", "question": "How does it work?", "priority": 2},
            {"id": "q4", "question": "What are the applications?", "priority": 2},
            {"id": "q5", "question": "What are the limitations?", "priority": 3}
        ],
        "dependencies": {
            "q1": [],
            "q2": [],
            "q3": ["q1", "q2"],  # How it works depends on definition and components
            "q4": ["q3"],        # Applications depend on understanding how it works
            "q5": ["q3"]         # Limitations also depend on understanding how it works
        }
    }
    analyze_research_plan(valid_plan)

    # Example 2: Circular dependency graph
    print("\n\n" + "="*80)
    print("ðŸ§ª Example 2: INVALID Dependency Graph (Circular)")
    print("="*80)
    circular_plan = {
        "atomic_questions": [
            {"id": "q1", "question": "What are the key applications?", "priority": 1},
            {"id": "q2", "question": "What are the limitations?", "priority": 2},
            {"id": "q3", "question": "How does it compare to alternatives?", "priority": 2},
            {"id": "q4", "question": "What are the best practices?", "priority": 3}
        ],
        "dependencies": {
            "q1": ["q3"],  # Applications depend on comparisons
            "q2": ["q1"],  # Limitations depend on applications
            "q3": ["q2"],  # Comparisons depend on limitations (CYCLE!)
            "q4": ["q1"]   # Best practices depend on applications
        }
    }
    analyze_research_plan(circular_plan)

    print("\n" + "="*80)
    print("Diagnostic complete!")
    print("="*80)


if __name__ == "__main__":
    main()
