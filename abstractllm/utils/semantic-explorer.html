<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Semantic Graph Explorer</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; background-color: #f7f9fc; color: #333; }
    .container { display: flex; height: 100vh; flex-direction: column; }
    .header { background-color: #2c3e50; color: white; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; }
    .header h1 { margin: 0; font-size: 20px; }
    .file-controls { display: flex; align-items: center; }
    .main-container { display: flex; flex: 1; overflow: hidden; }
    .sidebar { width: 280px; background-color: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); padding: 15px; overflow-y: auto; display: flex; flex-direction: column; }
    .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .graph-container { flex: 1; background-color: #fff; margin: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); position: relative; overflow: hidden; }
    .details-panel { height: 230px; background-color: #fff; margin: 0 10px 10px 10px; padding: 15px; box-shadow: 0 0 10px rgba(0,0,0,0.1); overflow-y: auto; }
    .entity-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex: 1; }
    .entity-item { padding: 10px; margin-bottom: 5px; background-color: #f8f9fa; border-left: 3px solid #6c757d; cursor: pointer; border-radius: 3px; transition: all 0.2s; }
    .entity-item:hover { background-color: #e9ecef; transform: translateX(2px); }
    .entity-item.selected { background-color: #e3f2fd; border-left-color: #1976d2; }
    .entity-type { font-size: 11px; color: #666; margin-top: 3px; }
    #search-box { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; box-sizing: border-box; }
    h3 { color: #2c3e50; margin-top: 10px; margin-bottom: 10px; font-size: 16px; }
    .details-title { display: flex; justify-content: space-between; align-items: center; }
    .details-title h3 { margin: 0; }
    .detail-type { font-size: 12px; color: #666; font-style: italic; }
    .property { margin-bottom: 8px; }
    .property-name { font-weight: bold; font-size: 13px; color: #555; }
    .property-value { margin-top: 3px; word-break: break-word; font-size: 14px; }
    .relationship-link { color: #1976d2; cursor: pointer; text-decoration: underline; }
    .zoom-controls { position: absolute; top: 10px; right: 10px; background-color: white; border-radius: 4px; box-shadow: 0 0 10px rgba(0,0,0,0.1); padding: 5px; z-index: 10; }
    .zoom-btn { width: 30px; height: 30px; background-color: #fff; border: 1px solid #ddd; margin: 2px; cursor: pointer; border-radius: 3px; font-size: 16px; }
    .zoom-btn:hover { background-color: #f5f5f5; }
    #legend { position: absolute; bottom: 10px; left: 10px; background-color: white; padding: 8px; border-radius: 4px; box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 10; font-size: 12px; }
    .legend-item { display: flex; align-items: center; margin: 5px 0; }
    .legend-color { width: 12px; height: 12px; border-radius: 2px; margin-right: 8px; }
    .tab-container { display: flex; margin-bottom: 10px; border-bottom: 1px solid #ddd; }
    .tab { padding: 8px 15px; cursor: pointer; font-size: 14px; background-color: #f8f9fa; border: 1px solid transparent; margin-right: 3px; border-radius: 4px 4px 0 0; }
    .tab.active { background-color: #fff; border-color: #ddd; border-bottom-color: #fff; margin-bottom: -1px; }
    .tab-content { display: none; overflow-y: auto; flex: 1; }
    .tab-content.active { display: block; }
    .filter-group { margin-bottom: 15px; }
    .filter-label { font-size: 13px; font-weight: bold; margin-bottom: 8px; display: block; }
    .filter-options { display: flex; flex-wrap: wrap; gap: 5px; }
    .filter-option { padding: 4px 8px; background-color: #e9ecef; border-radius: 3px; font-size: 12px; cursor: pointer; }
    .filter-option.active { background-color: #1976d2; color: white; }
    .summary { background-color: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 14px; }
    .file-input-container { position: relative; display: inline-block; margin-right: 10px; }
    .file-input-label { display: inline-block; padding: 6px 12px; background-color: #4CAF50; color: white; border-radius: 4px; cursor: pointer; font-size: 14px; }
    .file-input { position: absolute; left: 0; top: 0; opacity: 0; width: 0.1px; height: 0.1px; }
    .file-name { font-size: 14px; color: #ddd; margin-left: 10px; }
    .button { padding: 6px 12px; margin-left: 10px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
    .no-data { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; color: #6c757d; }
    .no-data-icon { font-size: 48px; margin-bottom: 10px; }
    pre { background-color: #f8f9fa; padding: 10px; border-radius: 4px; overflow: auto; max-height: 400px; margin: 0; font-size: 12px; }
    .category-stats { background-color: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 14px; }
    .category-count { display: flex; justify-content: space-between; margin-bottom: 5px; }
    .relationship-detail { background-color: #f5f7fa; padding: 8px; border-radius: 4px; margin-top: 5px; }
    .tooltip { position: absolute; display: none; background-color: rgba(0, 0, 0, 0.7); color: #fff; padding: 5px 10px; border-radius: 3px; font-size: 12px; z-index: 100; max-width: 200px; }
    .loading { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); display: none; }
    .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #1976d2; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .status-message { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #333; color: white; padding: 10px 20px; border-radius: 4px; z-index: 1000; display: none; }
    .debug-info { position: absolute; top: 50px; right: 10px; background-color: rgba(0,0,0,0.7); color: white; padding: 5px; font-family: monospace; font-size: 10px; max-width: 300px; z-index: 1000; }
    #clear-filters-btn { display: block; width: 100%; margin-top: 15px; background-color: #f44336; color: white; border: none; border-radius: 4px; padding: 8px; cursor: pointer; font-size: 14px; }
    #clear-filters-btn:hover { background-color: #d32f2f; }
    .filtered-node { opacity: 0.3; }
    .filtered-link { opacity: 0.1; }
    .filter-status { font-size: 12px; color: #666; margin-top: 5px; font-style: italic; }
    .node-tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px;  /* Increased overall padding */
      border-radius: 4px;
      font-size: 12px;
      max-width: 300px;
      z-index: 1000;
      pointer-events: none;
      transition: all 0.1s ease-out;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .node-tooltip .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
      gap: 12px;
      margin-left: -2px;  /* Reduce left margin to align with description */
    }
    .node-tooltip .title {
      font-weight: bold;
      font-size: 13px;  /* Increased from 11px */
      line-height: 1.3;
      flex: 1;
      text-align: left;
    }
    .node-tooltip .type-badge {
      font-size: 12px;  /* Increased from 10px */
      padding: 4px 10px;  /* Increased padding */
      border-radius: 3px;
      color: white;
      text-transform: capitalize;
      white-space: nowrap;
      text-align: right;
      flex-shrink: 0;
    }
    .node-tooltip .description {
      font-size: 12px;  /* Increased from 11px */
      line-height: 1.4;
      opacity: 0.9;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Semantic Graph Explorer</h1>
      <div class="file-controls">
        <div class="file-input-container">
          <label for="file-input" class="file-input-label">Load Semantic Data</label>
          <input type="file" id="file-input" class="file-input" accept=".json">
        </div>
        <span class="file-name" id="file-name">No file selected</span>
        <button id="export-btn" class="button">Export Data</button>
      </div>
    </div>
    <div class="main-container">
      <div class="sidebar">
        <div class="tab-container">
          <div class="tab active" data-tab="entities">Entities</div>
          <div class="tab" data-tab="filters">Filters</div>
          <div class="tab" data-tab="stats">Statistics</div>
        </div>
        
        <div class="tab-content active" id="entities-tab">
          <input type="text" id="search-box" placeholder="Search entities...">
          <div class="entity-list" id="entity-list"></div>
        </div>
        
        <div class="tab-content" id="filters-tab">
          <button id="clear-filters-btn">Clear All Filters</button>
          <div class="filter-status" id="filter-status"></div>
          <div class="filter-group">
            <span class="filter-label">Entity Types</span>
            <div class="filter-options" id="type-filters"></div>
          </div>
          <div class="filter-group">
            <span class="filter-label">Categories</span>
            <div class="filter-options" id="category-filters"></div>
          </div>
          <div class="filter-group">
            <span class="filter-label">Relationship Types</span>
            <div class="filter-options" id="relationship-filters"></div>
          </div>
        </div>
        
        <div class="tab-content" id="stats-tab">
          <div class="category-stats" id="stats-container">
            <h3>Graph Statistics</h3>
            <p>Load a semantic graph to view statistics.</p>
          </div>
        </div>
      </div>
      
      <div class="main-content">
        <div class="graph-container" id="graph-container">
          <div class="zoom-controls">
            <button class="zoom-btn" id="zoom-in">+</button>
            <button class="zoom-btn" id="zoom-out">-</button>
            <button class="zoom-btn" id="zoom-reset">âŸ²</button>
          </div>
          <div id="legend"></div>
          <div class="no-data" id="no-data">
            <div class="no-data-icon">ðŸ“Š</div>
            <p>Load a semantic graph data file to begin</p>
          </div>
          <div class="loading" id="loading">
            <div class="spinner"></div>
          </div>
          <div class="tooltip" id="tooltip"></div>
          <div class="debug-info" id="debug-info"></div>
        </div>
        <div class="details-panel">
          <div class="details-title">
            <h3 id="details-title">Select an entity to view details</h3>
            <span class="detail-type" id="details-type"></span>
          </div>
          <div id="details-content"></div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="status-message" id="status-message"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script>
    // Global variables
    let semanticGraph = null;
    let entities = {};
    let relationships = [];
    let nodes = [];
    let links = [];
    let simulation = null;
    let svg = null;
    let g = null;
    let zoom = null;
    let link = null;
    let linkText = null;
    let node = null;
    
    // Filter states
    let activeTypeFilters = new Set();
    let activeCategoryFilters = new Set();
    let activeRelationshipFilters = new Set();
    let searchQuery = '';
    
    // Colors for entity categories
    const categoryColors = {
      "schema:Publication": "#4CAF50",
      "schema:Concept": "#673AB7",
      "schema:Theory": "#2196F3",
      "schema:Method": "#FF9800",
      "schema:Definition": "#9C27B0",
      "schema:Category": "#607D8B",
      "schema:ScholarlyField": "#795548",
      "schema:Topic": "#3F51B5",
      "schema:Domain": "#009688",
      "schema:Paradigm": "#E91E63",
      "schema:Substance": "#FFC107",
      "schema:Organism": "#8BC34A",
      "schema:Structure": "#00BCD4",
      "schema:NaturalPhenomenon": "#FFEB3B",
      "schema:Environment": "#CDDC39",
      "schema:Dataset": "#03A9F4",
      "schema:Publication": "#E91E63",
      "schema:Model": "#9E9E9E",
      "schema:Algorithm": "#FF5722",
      "schema:Specification": "#795548",
      "schema:Process": "#009688",
      "schema:Investigation": "#F44336",
      "schema:Analysis": "#3F51B5",
      "schema:Transformation": "#FF9800",
      "schema:Interaction": "#9C27B0",
      "schema:TimeFrame": "#607D8B",
      "schema:Context": "#795548",
      "schema:State": "#009688",
      "schema:Phase": "#E91E63",
      "schema:Agent": "#FFC107",
      "schema:Group": "#8BC34A",
      "schema:Institution": "#00BCD4",
      "schema:System": "#FFEB3B",
      "skos:Concept": "#673AB7",
      "default": "#888888"
    };
    
    // Initialize the application
    document.addEventListener('DOMContentLoaded', initializeApp);
    
    function initializeApp() {
      setupEventListeners();
      setupTabs();
      
      // Debug information - visible on initialization
      document.getElementById('debug-info').textContent = "Explorer initialized. Waiting for data...";
    }
    
    function setupEventListeners() {
      // File input change
      document.getElementById('file-input').addEventListener('change', handleFileSelect);
      
      // Zoom controls
      document.getElementById('zoom-in').addEventListener('click', zoomIn);
      document.getElementById('zoom-out').addEventListener('click', zoomOut);
      document.getElementById('zoom-reset').addEventListener('click', resetZoom);
      
      // Search box
      document.getElementById('search-box').addEventListener('input', handleSearch);
      
      // Export button
      document.getElementById('export-btn').addEventListener('click', exportData);
      
      // Clear filters button
      document.getElementById('clear-filters-btn').addEventListener('click', clearAllFilters);
    }
    
    function setupTabs() {
      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', function() {
          // Remove active class from all tabs
          tabs.forEach(t => t.classList.remove('active'));
          // Add active class to clicked tab
          this.classList.add('active');
          
          // Hide all tab content
          document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
          });
          
          // Show the selected tab content
          const tabId = this.getAttribute('data-tab');
          document.getElementById(tabId + '-tab').classList.add('active');
        });
      });
    }
    
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      document.getElementById('file-name').textContent = file.name;
      document.getElementById('loading').style.display = 'block';
      document.getElementById('debug-info').textContent = "Loading file: " + file.name;
      
      const reader = new FileReader();
      
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          processData(data);
          showStatusMessage("Data loaded successfully", "success");
        } catch (error) {
          console.error("Error parsing JSON:", error);
          document.getElementById('debug-info').textContent = "Error: " + error.message;
          showStatusMessage("Error loading data: " + error.message, "error");
        } finally {
          document.getElementById('loading').style.display = 'none';
        }
      };
      
      reader.onerror = function() {
        console.error("Error reading file");
        document.getElementById('debug-info').textContent = "Error reading file";
        showStatusMessage("Error reading file", "error");
        document.getElementById('loading').style.display = 'none';
      };
      
      reader.readAsText(file);
    }
    
    function processData(data) {
      console.log("Processing data:", data);
      semanticGraph = data;
      
      // Clear previous data
      entities = {};
      relationships = [];
      nodes = [];
      links = [];
      
      // Clear filters
      activeTypeFilters.clear();
      activeCategoryFilters.clear();
      activeRelationshipFilters.clear();
      searchQuery = '';
      document.getElementById('search-box').value = '';
      
      // Clear visualizations
      clearVisualization();
      
      // Process entities
      if (semanticGraph["@graph"] && Array.isArray(semanticGraph["@graph"])) {
        semanticGraph["@graph"].forEach(node => {
          if (node["@id"] && !node["@id"].startsWith("relationship:")) {
            entities[node["@id"]] = {
              id: node["@id"],
              label: node["schema:name"] || node["skos:definition"] || node["@id"].split(':')[1],
              type: node["@type"] || "Unknown",
              category: node["@type"] || "Unknown",
              properties: { ...node }
            };
          }
        });
        
        // Process relationships
        semanticGraph["@graph"].forEach(node => {
          // Direct relationships in properties
          Object.entries(node).forEach(([key, value]) => {
            if (typeof value === 'object' && value !== null && value["@id"] && key !== "@id" && key !== "@type") {
              const sourceId = node["@id"];
              const targetId = value["@id"];
              
              if (entities[sourceId] && entities[targetId]) {
                relationships.push({
                  id: `${sourceId}-${key}-${targetId}`,
                  source: sourceId,
                  target: targetId,
                  type: key,
                  label: key.split(':').pop(),
                  properties: { relationship: key }
                });
              }
            }
          });
          
          // Explicit relationship nodes
          if (node["@id"] && node["@id"].startsWith("relationship:")) {
            if (node["schema:about"] && node["schema:object"]) {
              const sourceId = node["schema:about"]["@id"];
              const targetId = node["schema:object"]["@id"];
              
              if (entities[sourceId] && entities[targetId]) {
                relationships.push({
                  id: node["@id"],
                  source: sourceId,
                  target: targetId,
                  type: node["@type"],
                  label: node["@type"].split(':').pop(),
                  properties: { ...node }
                });
              }
            }
          }
        });
      }
      
      // Convert to arrays for D3
      nodes = Object.values(entities);
      links = relationships.map(r => ({
        ...r,
        source: r.source,
        target: r.target
      }));
      
      // Debug information
      document.getElementById('debug-info').textContent = `Processed ${nodes.length} entities and ${links.length} relationships`;
      
      // Update UI
      populateEntityList(); // This needs to run immediately to show entities
      updateFilters();
      updateStatistics();
      createVisualization();
      
      // Hide no-data message
      document.getElementById('no-data').style.display = 'none';
    }
    
    function clearVisualization() {
      const container = document.getElementById('graph-container');
      const svg = container.querySelector('svg');
      if (svg) {
        svg.remove();
      }
      
      const legend = document.getElementById('legend');
      legend.innerHTML = '';
      
      // Reset details
      document.getElementById('details-title').textContent = 'Select an entity to view details';
      document.getElementById('details-type').textContent = '';
      document.getElementById('details-content').innerHTML = '';
    }


    function createVisualization() {
      console.log("Creating visualization with entities:", nodes.length);
      console.log("and relationships:", links.length);
      
      if (nodes.length === 0) {
        document.getElementById('debug-info').textContent = "No entities found to visualize";
        return;
      }
      
      const container = document.getElementById('graph-container');
      const width = container.offsetWidth;
      const height = container.offsetHeight;
      
      // Setup SVG
      svg = d3.select('#graph-container')
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', [0, 0, width, height]);
      
      // Add zoom
      zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on('zoom', event => g.attr('transform', event.transform));
      
      svg.call(zoom);
      g = svg.append('g');
      
      // Arrow marker for links
      svg.append('defs').append('marker')
        .attr('id', 'arrow')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 15)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');
      
      // Setup force simulation
      simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(d => {
          // Calculate distance based on source and target nodes' degrees
          const sourceConnections = links.filter(l => 
            (l.source.id || l.source) === (d.source.id || d.source) || 
            (l.target.id || l.target) === (d.source.id || d.source)
          ).length;
          const targetConnections = links.filter(l => 
            (l.source.id || l.source) === (d.target.id || d.target) || 
            (l.target.id || l.target) === (d.target.id || d.target)
          ).length;
          
          // More connected nodes need more space
          const baseDistance = d.source.id.startsWith('relationship:') || d.target.id.startsWith('relationship:') ? 200 : 150;
          return baseDistance * (1 + Math.log(sourceConnections + targetConnections) * 0.2);
        }))
        .force('charge', d3.forceManyBody()
          .strength(d => {
            // Calculate node's degree
            const degree = links.filter(l => 
              (l.source.id || l.source) === d.id || 
              (l.target.id || l.target) === d.id
            ).length;
            // More connected nodes have stronger repulsion
            const baseStrength = d.id.startsWith('relationship:') ? -150 : -400;
            return baseStrength * (1 + Math.log(degree + 1) * 0.3);
          })
          .distanceMax(2000))
        .force('center', d3.forceCenter(width/2, height/2))
        .force('collide', d3.forceCollide().radius(d => {
          // Larger collision radius for more connected nodes
          const degree = links.filter(l => 
            (l.source.id || l.source) === d.id || 
            (l.target.id || l.target) === d.id
          ).length;
          return 40 * (1 + Math.log(degree + 1) * 0.2);
        }))
        .velocityDecay(0.3);

      // Add CSS for enhanced tooltip
      const style = document.createElement('style');
      style.textContent = `
        .node-tooltip {
          position: absolute;
          background-color: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 12px;  /* Increased overall padding */
          border-radius: 4px;
          font-size: 12px;
          max-width: 300px;
          z-index: 1000;
          pointer-events: none;
          transition: all 0.1s ease-out;
          box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .node-tooltip .header {
          display: flex;
          justify-content: space-between;
          align-items: flex-start;
          margin-bottom: 10px;
          gap: 12px;
          margin-left: -2px;  /* Reduce left margin to align with description */
        }
        .node-tooltip .title {
          font-weight: bold;
          font-size: 13px;  /* Increased from 11px */
          line-height: 1.3;
          flex: 1;
          text-align: left;
        }
        .node-tooltip .type-badge {
          font-size: 12px;  /* Increased from 10px */
          padding: 4px 10px;  /* Increased padding */
          border-radius: 3px;
          color: white;
          text-transform: capitalize;
          white-space: nowrap;
          text-align: right;
          flex-shrink: 0;
        }
        .node-tooltip .description {
          font-size: 12px;  /* Increased from 11px */
          line-height: 1.4;
          opacity: 0.9;
          border-top: 1px solid rgba(255, 255, 255, 0.1);
          padding-top: 10px;
        }
      `;
      document.head.appendChild(style);

      // Initial positioning in a wider circle
      const radius = Math.min(width, height) / 2.5;  // Increased radius
      nodes.forEach((d, i) => {
        const angle = (i / nodes.length) * 2 * Math.PI;
        d.x = width/2 + radius * Math.cos(angle);
        d.y = height/2 + radius * Math.sin(angle);
      });

      // Create links
      link = g.append('g')
        .selectAll('line')
        .data(links)
        .enter().append('line')
        .attr('class', d => `link-item link-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
        .attr('stroke', '#999')
        .attr('stroke-width', 1)
        .attr('marker-end', 'url(#arrow)');
      
      // Link labels
      linkText = g.append('g')
        .selectAll('text')
        .data(links)
        .enter().append('text')
        .attr('class', d => `link-text-item link-text-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
        .attr('font-size', '8px')
        .attr('text-anchor', 'middle')
        .attr('dy', -3)
        .text(d => d.label);
      
      // Create nodes
      const getNodeColor = d => categoryColors[d.category] || categoryColors["default"];
      
      node = g.append('g')
        .selectAll('g')
        .data(nodes)
        .enter().append('g')
        .attr('class', d => `node-item node-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
        .call(d3.drag()
          .on('start', dragstart)
          .on('drag', dragging)
          .on('end', dragend))
        .on('click', showDetails)
        .on('mouseover', function(event, d) {
          // Highlight node contour
          d3.select(this).select('circle')
            .attr('stroke', '#e91e63')
            .attr('stroke-width', 2);

          // Find and highlight connected links
          const nodeId = d.id;
          const connectedLinks = links.filter(l => 
            (typeof l.source === 'object' ? l.source.id === nodeId : l.source === nodeId) || 
            (typeof l.target === 'object' ? l.target.id === nodeId : l.target === nodeId)
          );

          // Highlight links
          link.filter(l => {
            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
            return sourceId === nodeId || targetId === nodeId;
          })
            .attr('stroke', '#e91e63')
            .attr('stroke-width', 2);

          // Highlight link text
          linkText.filter(l => {
            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
            return sourceId === nodeId || targetId === nodeId;
          })
            .attr('font-weight', 'bold')
            .attr('fill', '#e91e63');

          // Show tooltip
          const tooltip = document.createElement('div');
          tooltip.className = 'node-tooltip';
          tooltip.id = 'active-tooltip';
          
          // Create header with title and type badge
          const header = document.createElement('div');
          header.className = 'header';
          
          const title = document.createElement('div');
          title.className = 'title';
          title.textContent = d.label;
          
          const typeBadge = document.createElement('div');
          typeBadge.className = 'type-badge';
          typeBadge.textContent = d.type.split(':').pop();
          typeBadge.style.backgroundColor = categoryColors[d.category] || categoryColors["default"];
          
          header.appendChild(title);
          header.appendChild(typeBadge);
          
          const description = document.createElement('div');
          description.className = 'description';
          description.textContent = d.properties["schema:description"] || 'No description available';
          
          tooltip.appendChild(header);
          tooltip.appendChild(description);
          document.body.appendChild(tooltip);
          
          // Position tooltip near the node
          const nodeBox = this.getBoundingClientRect();
          const tooltipBox = tooltip.getBoundingClientRect();
          
          // Calculate position relative to the node
          const top = nodeBox.top - tooltipBox.height - 10;
          const left = nodeBox.left + (nodeBox.width / 2) - (tooltipBox.width / 2);
          
          // Ensure tooltip stays within viewport
          tooltip.style.top = `${Math.max(10, top)}px`;
          tooltip.style.left = `${Math.max(10, Math.min(window.innerWidth - tooltipBox.width - 10, left))}px`;
        })
        .on('mouseout', function(event, d) {
          // Remove node highlight
          d3.select(this).select('circle')
            .attr('stroke', null)
            .attr('stroke-width', null);

          // Reset all links and link text
          link
            .attr('stroke', '#999')
            .attr('stroke-width', 1);
          
          linkText
            .attr('font-weight', 'normal')
            .attr('fill', '#666');

          // Remove tooltip
          const tooltip = document.getElementById('active-tooltip');
          if (tooltip) {
            tooltip.remove();
          }
        });
      
      node.append('circle')
        .attr('r', 8)
        .attr('fill', getNodeColor);
      
      node.append('text')
        .attr('font-size', '10px')
        .attr('x', 10)
        .attr('dy', 4)
        .text(d => d.label);

      // Gradually increase forces
      let alpha = 0;
      const targetAlpha = 1;
      const steps = 300;  // More steps for smoother transition
      const alphaStep = targetAlpha / steps;
      let layoutPhase = 'initial';  // Track layout phase

      function tick() {
        if (alpha < targetAlpha) {
          alpha += alphaStep;
          simulation.alpha(alpha);
          
          // Adjust force strengths gradually
          simulation.force('link').strength(alpha * 0.5);
          simulation.force('charge').strength(d => alpha * (d.id.startsWith('relationship:') ? -150 : -400));
          simulation.force('collide').strength(alpha * 0.7);
          
          // Only apply boundaries in the final phase
          if (layoutPhase === 'initial' && alpha > 0.7) {
            layoutPhase = 'final';
          }
          
          if (layoutPhase === 'final') {
            // Apply gentle boundary forces
            nodes.forEach(d => {
              const padding = 100;  // Increased padding
              if (d.x < padding) d.x += (padding - d.x) * 0.1;
              if (d.x > width - padding) d.x -= (d.x - (width - padding)) * 0.1;
              if (d.y < padding) d.y += (padding - d.y) * 0.1;
              if (d.y > height - padding) d.y -= (d.y - (height - padding)) * 0.1;
            });
          }
          
          requestAnimationFrame(tick);
        }
      }

      // Start the gradual force application
      tick();
      
      // Update positions on each simulation tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
          
        linkText
          .attr('x', d => (d.source.x + d.target.x)/2)
          .attr('y', d => (d.source.y + d.target.y)/2);
          
        node.attr('transform', d => `translate(${d.x},${d.y})`);
      });
      
      // Create legend
      createLegend();
      
      // Additional call to ensure entities are populated once simulation has started
      simulation.on('end', () => {
        // This will ensure the entity list is populated after the simulation has settled
        populateEntityList();
        updateStatistics();
        document.getElementById('debug-info').textContent = `Visualization complete: ${nodes.length} entities, ${links.length} relationships`;
      });
    }
    
    function createLegend() {
      const legend = document.getElementById('legend');
      legend.innerHTML = '';
      
      // Get unique categories from entities, sorted alphabetically
      const categories = [...new Set(nodes.map(n => n.category))].sort();
      
      categories.forEach(category => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        
        const colorBox = document.createElement('div');
        colorBox.className = 'legend-color';
        colorBox.style.backgroundColor = categoryColors[category] || categoryColors["default"];
        
        const label = document.createElement('div');
        // Show only the type part after the prefix (e.g., "schema:Publication" -> "Publication")
        label.textContent = category.split(':').pop();
        
        item.appendChild(colorBox);
        item.appendChild(label);
        legend.appendChild(item);
      });
    }
    
    // Function to apply filters to the graph
    function applyFiltersToGraph() {
      // Skip if no visualization exists yet
      if (!node || !link || !linkText) {
        return;
      }
      
      document.getElementById('debug-info').textContent = 
        `Applying filters... (${activeTypeFilters.size} types, ${activeCategoryFilters.size} categories, search: "${searchQuery}")`;

      // Get filtered nodes based on current filter settings
      let filteredNodeIds = new Set(nodes.map(n => n.id)); // Start with all nodes
      
      // Apply search filter
      if (searchQuery) {
        const matchingNodeIds = new Set(
          nodes.filter(n => 
            n.label.toLowerCase().includes(searchQuery.toLowerCase()) || 
            n.id.toLowerCase().includes(searchQuery.toLowerCase())
          ).map(n => n.id)
        );
        
        // Intersect with current filtered set
        filteredNodeIds = new Set(
          [...filteredNodeIds].filter(id => matchingNodeIds.has(id))
        );
      }
      
      // Apply type filter
      if (activeTypeFilters.size > 0) {
        const matchingNodeIds = new Set(
          nodes.filter(n => activeTypeFilters.has(n.type)).map(n => n.id)
        );
        
        // Intersect with current filtered set
        filteredNodeIds = new Set(
          [...filteredNodeIds].filter(id => matchingNodeIds.has(id))
        );
      }
      
      // Apply category filter
      if (activeCategoryFilters.size > 0) {
        const matchingNodeIds = new Set(
          nodes.filter(n => activeCategoryFilters.has(n.category)).map(n => n.id)
        );
        
        // Intersect with current filtered set
        filteredNodeIds = new Set(
          [...filteredNodeIds].filter(id => matchingNodeIds.has(id))
        );
      }
      
      // Now determine which links should be visible (only those connecting visible nodes)
      const filteredLinkIds = new Set(
        links.filter(l => {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          return filteredNodeIds.has(sourceId) && filteredNodeIds.has(targetId);
        }).map(l => l.id)
      );
      
      // Update the graph visualization to show/hide nodes and links
      node.style('display', d => filteredNodeIds.has(d.id) ? null : 'none');
      
      link.style('display', d => filteredLinkIds.has(d.id) ? null : 'none');
      
      linkText.style('display', d => filteredLinkIds.has(d.id) ? null : 'none');
      
      // Update debug info
      document.getElementById('debug-info').textContent = 
        `Filtered graph: showing ${filteredNodeIds.size} of ${nodes.length} nodes and ${filteredLinkIds.size} of ${links.length} links`;
        
      // Update filter status
      updateFilterStatus(filteredNodeIds.size, filteredLinkIds.size);
    }
    
    function updateFilterStatus(nodeCount, linkCount) {
      const statusEl = document.getElementById('filter-status');
      
      if (activeTypeFilters.size > 0 || activeCategoryFilters.size > 0 || searchQuery) {
        statusEl.textContent = `Showing ${nodeCount} of ${nodes.length} entities and ${linkCount} of ${links.length} relationships`;
        statusEl.style.display = 'block';
      } else {
        statusEl.textContent = '';
        statusEl.style.display = 'none';
      }
    }
    
    function populateEntityList(filtered = false) {
      const container = document.getElementById('entity-list');
      container.innerHTML = '';
      
      if (nodes.length === 0) {
        const noEntities = document.createElement('div');
        noEntities.textContent = "No entities to display";
        noEntities.style.padding = "10px";
        noEntities.style.color = "#888";
        container.appendChild(noEntities);
        return;
      }
      
      let filteredNodes = [...nodes]; // Create a copy to avoid modifying the original
      
      // Apply search filter
      if (searchQuery) {
        filteredNodes = filteredNodes.filter(n => 
          n.label.toLowerCase().includes(searchQuery.toLowerCase()) || 
          n.id.toLowerCase().includes(searchQuery.toLowerCase())
        );
      }
      
      // Apply type filter
      if (activeTypeFilters.size > 0) {
        filteredNodes = filteredNodes.filter(n => activeTypeFilters.has(n.type));
      }
      
      // Apply category filter
      if (activeCategoryFilters.size > 0) {
        filteredNodes = filteredNodes.filter(n => activeCategoryFilters.has(n.category));
      }
      
      // Always show some debug info
      document.getElementById('debug-info').textContent = 
        `Displaying ${filteredNodes.length} of ${nodes.length} entities`;
      
      filteredNodes.forEach(entity => {
        const div = document.createElement('div');
        div.className = 'entity-item';
        div.dataset.id = entity.id;
        div.innerHTML = `
          <strong>${entity.label}</strong>
          <div class="entity-type">${entity.type.split(':').pop()}</div>
        `;
        div.onclick = () => {
          document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('selected'));
          div.classList.add('selected');
          showDetails(null, entity);
          highlightConnections(entity);
        };
        container.appendChild(div);
      });
      
      // Apply filters to the graph visualization
      if (filtered) {
        applyFiltersToGraph();
      }
    }
    
    function updateFilters() {
      if (nodes.length === 0) {
        // No data to filter
        document.getElementById('type-filters').innerHTML = '<div>No data available</div>';
        document.getElementById('category-filters').innerHTML = '<div>No data available</div>';
        document.getElementById('relationship-filters').innerHTML = '<div>No data available</div>';
        return;
      }
      
      // Get unique types and categories
      const types = [...new Set(nodes.map(n => n.type))];
      const categories = [...new Set(nodes.map(n => n.category))];
      const relationshipTypes = [...new Set(links.map(l => l.type))];
      
      // Populate type filters
      const typeFilters = document.getElementById('type-filters');
      typeFilters.innerHTML = '';
      types.forEach(type => {
        const filter = document.createElement('div');
        filter.className = 'filter-option';
        filter.textContent = type.split(':').pop();
        filter.dataset.value = type;
        if (activeTypeFilters.has(type)) {
          filter.classList.add('active');
        }
        filter.onclick = function() {
          this.classList.toggle('active');
          if (this.classList.contains('active')) {
            activeTypeFilters.add(type);
          } else {
            activeTypeFilters.delete(type);
          }
          populateEntityList(true); // true = apply filters to graph
        };
        typeFilters.appendChild(filter);
      });
      
      // Populate category filters
      const categoryFilters = document.getElementById('category-filters');
      categoryFilters.innerHTML = '';
      categories.forEach(category => {
        const filter = document.createElement('div');
        filter.className = 'filter-option';
        filter.textContent = category;
        filter.dataset.value = category;
        filter.style.backgroundColor = categoryColors[category] || '#888';
        filter.style.color = 'white';
        if (activeCategoryFilters.has(category)) {
          filter.classList.add('active');
        }
        filter.onclick = function() {
          this.classList.toggle('active');
          if (this.classList.contains('active')) {
            activeCategoryFilters.add(category);
          } else {
            activeCategoryFilters.delete(category);
          }
          populateEntityList(true); // true = apply filters to graph
        };
        categoryFilters.appendChild(filter);
      });
      
      // Populate relationship filters
      const relationshipFilters = document.getElementById('relationship-filters');
      relationshipFilters.innerHTML = '';
      relationshipTypes.forEach(type => {
        const filter = document.createElement('div');
        filter.className = 'filter-option';
        filter.textContent = type.split(':').pop();
        filter.dataset.value = type;
        if (activeRelationshipFilters.has(type)) {
          filter.classList.add('active');
        }
        filter.onclick = function() {
          this.classList.toggle('active');
          if (this.classList.contains('active')) {
            activeRelationshipFilters.add(type);
          } else {
            activeRelationshipFilters.delete(type);
          }
          // Highlight relationships in the visualization
          highlightRelationshipsByType();
        };
        relationshipFilters.appendChild(filter);
      });
    }
    
    function highlightRelationshipsByType() {
      // Reset relationship styling
      link.attr('stroke', '#999').attr('stroke-width', 1);
      linkText.attr('font-weight', 'normal').attr('fill', '#666');
      
      if (activeRelationshipFilters.size === 0) {
        return; // No filters active
      }
      
      // Highlight relationships matching active filters
      link.filter(l => activeRelationshipFilters.has(l.type))
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 2);
      
      linkText.filter(l => activeRelationshipFilters.has(l.type))
        .attr('font-weight', 'bold')
        .attr('fill', '#e91e63');
    }
    
    function updateStatistics() {
      const container = document.getElementById('stats-container');
      container.innerHTML = '';
      
      const title = document.createElement('h3');
      title.textContent = 'Graph Statistics';
      container.appendChild(title);
      
      if (nodes.length === 0 || links.length === 0) {
        const noData = document.createElement('p');
        noData.textContent = 'No data available for statistics';
        container.appendChild(noData);
        return;
      }
      
      // Entity count by category
      const categoryTitle = document.createElement('h4');
      categoryTitle.textContent = 'Entities by Category';
      container.appendChild(categoryTitle);
      
      const categoryStats = {};
      nodes.forEach(node => {
        categoryStats[node.category] = (categoryStats[node.category] || 0) + 1;
      });
      
      Object.entries(categoryStats).forEach(([category, count]) => {
        const div = document.createElement('div');
        div.className = 'category-count';
        div.innerHTML = `
          <span>${category}:</span>
          <span>${count}</span>
        `;
        container.appendChild(div);
      });
      
      // Relationship count by type
      const relationshipTitle = document.createElement('h4');
      relationshipTitle.textContent = 'Relationships by Type';
      container.appendChild(relationshipTitle);
      
      const relationshipStats = {};
      links.forEach(link => {
        relationshipStats[link.type] = (relationshipStats[link.type] || 0) + 1;
      });
      
      Object.entries(relationshipStats).forEach(([type, count]) => {
        const div = document.createElement('div');
        div.className = 'category-count';
        div.innerHTML = `
          <span>${type.split(':').pop()}:</span>
          <span>${count}</span>
        `;
        container.appendChild(div);
      });
      
      // Total counts
      const summary = document.createElement('div');
      summary.className = 'summary';
      summary.innerHTML = `
        <strong>Total Entities:</strong> ${nodes.length}<br>
        <strong>Total Relationships:</strong> ${links.length}
      `;
      container.appendChild(summary);
    }
    
    function handleSearch(event) {
      searchQuery = event.target.value;
      populateEntityList(true); // true = apply filters to graph
    }
    
    function clearAllFilters() {
      activeTypeFilters.clear();
      activeCategoryFilters.clear();
      activeRelationshipFilters.clear();
      searchQuery = '';
      document.getElementById('search-box').value = '';
      
      // Update filter UI
      document.querySelectorAll('.filter-option').forEach(el => {
        el.classList.remove('active');
      });
      
      // Update entity list and graph
      populateEntityList(true);
      
      // Reset relationship highlighting
      link.attr('stroke', '#999').attr('stroke-width', 1);
      linkText.attr('font-weight', 'normal').attr('fill', '#666');
      
      // Update filter status
      document.getElementById('filter-status').textContent = '';
      document.getElementById('filter-status').style.display = 'none';
      
      showStatusMessage("All filters cleared", "info");
    }
    
    function showDetails(event, d) {
      const detailsTitle = document.getElementById('details-title');
      const detailsType = document.getElementById('details-type');
      const detailsContent = document.getElementById('details-content');
      
      detailsTitle.textContent = d.label;
      detailsType.textContent = d.type.split(':').pop();
      detailsContent.innerHTML = '';
      
      // Show description if available
      if (d.properties["schema:description"]) {
        const summary = document.createElement('div');
        summary.className = 'summary';
        summary.textContent = d.properties["schema:description"];
        detailsContent.appendChild(summary);
      }
      
      // Show additional property if available
      if (d.properties["schema:additionalProperty"]) {
        const additionalProp = document.createElement('div');
        additionalProp.className = 'property';
        additionalProp.innerHTML = `
          <div class="property-name">Additional details:</div>
          <div class="property-value">${d.properties["schema:additionalProperty"]}</div>
        `;
        detailsContent.appendChild(additionalProp);
      }
      
      // Show the entity ID
      const idProperty = document.createElement('div');
      idProperty.className = 'property';
      idProperty.innerHTML = `
        <div class="property-name">ID:</div>
        <div class="property-value">${d.id}</div>
      `;
      detailsContent.appendChild(idProperty);
      
      // Create properties section
      const propertiesContainer = document.createElement('div');
      
      // Get all properties except @id, @type, schema:description, and schema:additionalProperty (already shown)
      Object.entries(d.properties).forEach(([key, value]) => {
        if (key !== '@id' && key !== '@type' && key !== 'schema:description' && key !== 'schema:additionalProperty') {
          const propertyDiv = document.createElement('div');
          propertyDiv.className = 'property';
          
          const nameDiv = document.createElement('div');
          nameDiv.className = 'property-name';
          nameDiv.textContent = key;
          propertyDiv.appendChild(nameDiv);
          
          const valueDiv = document.createElement('div');
          valueDiv.className = 'property-value';
          
          if (typeof value === 'object' && value !== null) {
            if (value['@id']) {
              // Reference to another entity
              const link = document.createElement('span');
              link.className = 'relationship-link';
              link.textContent = value['@id'];
              link.onclick = () => {
                const target = nodes.find(n => n.id === value['@id']);
                if (target) {
                  showDetails(null, target);
                  highlightConnections(target);
                  
                  // Highlight in entity list
                  document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('selected'));
                  const el = document.querySelector(`.entity-item[data-id="${value['@id']}"]`);
                  if (el) {
                    el.classList.add('selected');
                    el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                  }
                }
              };
              valueDiv.appendChild(link);
            } else if (Array.isArray(value)) {
              // Array of values
              value.forEach((item, index) => {
                if (typeof item === 'object' && item !== null && item['@id']) {
                  const link = document.createElement('span');
                  link.className = 'relationship-link';
                  link.textContent = item['@id'];
                  link.onclick = () => {
                    const target = nodes.find(n => n.id === item['@id']);
                    if (target) {
                      showDetails(null, target);
                      highlightConnections(target);
                      
                      // Highlight in entity list
                      document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('selected'));
                      const el = document.querySelector(`.entity-item[data-id="${item['@id']}"]`);
                      if (el) {
                        el.classList.add('selected');
                        el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                      }
                    }
                  };
                  valueDiv.appendChild(link);
                  if (index < value.length - 1) {
                    valueDiv.appendChild(document.createTextNode(', '));
                  }
                } else {
                  valueDiv.appendChild(document.createTextNode(JSON.stringify(item)));
                  if (index < value.length - 1) {
                    valueDiv.appendChild(document.createTextNode(', '));
                  }
                }
              });
            } else {
              valueDiv.textContent = JSON.stringify(value);
            }
          } else {
            valueDiv.textContent = value;
          }
          
          propertyDiv.appendChild(valueDiv);
          propertiesContainer.appendChild(propertyDiv);
        }
      });
      
      detailsContent.appendChild(propertiesContainer);
      
      // Show connected relationships
      const relatedTitle = document.createElement('h4');
      relatedTitle.textContent = 'Related Entities';
      detailsContent.appendChild(relatedTitle);
      
      // Find connected relationships
      const connectedLinks = links.filter(l => 
        (typeof l.source === 'object' ? l.source.id === d.id : l.source === d.id) || 
        (typeof l.target === 'object' ? l.target.id === d.id : l.target === d.id)
      );
      
      if (connectedLinks.length > 0) {
        const incomingLinks = connectedLinks.filter(l => 
          (typeof l.target === 'object' ? l.target.id === d.id : l.target === d.id)
        );
        
        const outgoingLinks = connectedLinks.filter(l => 
          (typeof l.source === 'object' ? l.source.id === d.id : l.source === d.id)
        );
        
        // Incoming relationships
        if (incomingLinks.length > 0) {
          const incomingTitle = document.createElement('div');
          incomingTitle.className = 'property-name';
          incomingTitle.textContent = 'Incoming Relationships:';
          detailsContent.appendChild(incomingTitle);
          
          const incomingList = document.createElement('div');
          incomingList.className = 'property-value';
          
          incomingLinks.forEach(link => {
            const relationshipDiv = document.createElement('div');
            relationshipDiv.className = 'relationship-detail';
            
            // Source entity link
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const sourceLink = document.createElement('span');
            sourceLink.className = 'relationship-link';
            sourceLink.textContent = entities[sourceId].label;
            sourceLink.onclick = () => {
              const target = nodes.find(n => n.id === sourceId);
              if (target) {
                showDetails(null, target);
                highlightConnections(target);
                
                // Highlight in entity list
                document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('selected'));
                const el = document.querySelector(`.entity-item[data-id="${sourceId}"]`);
                if (el) {
                  el.classList.add('selected');
                  el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
              }
            };
            
            relationshipDiv.appendChild(sourceLink);
            relationshipDiv.appendChild(document.createTextNode(` â†’ [${link.label}] â†’ ${d.label}`));
            
            // Add description if available
            if (link.properties && link.properties["schema:description"]) {
              const descDiv = document.createElement('div');
              descDiv.style.fontSize = '12px';
              descDiv.style.marginTop = '5px';
              descDiv.textContent = link.properties["schema:description"];
              relationshipDiv.appendChild(descDiv);
            }
            
            incomingList.appendChild(relationshipDiv);
          });
          
          detailsContent.appendChild(incomingList);
        }
        
        // Outgoing relationships
        if (outgoingLinks.length > 0) {
          const outgoingTitle = document.createElement('div');
          outgoingTitle.className = 'property-name';
          outgoingTitle.style.marginTop = '10px';
          outgoingTitle.textContent = 'Outgoing Relationships:';
          detailsContent.appendChild(outgoingTitle);
          
          const outgoingList = document.createElement('div');
          outgoingList.className = 'property-value';
          
          outgoingLinks.forEach(link => {
            const relationshipDiv = document.createElement('div');
            relationshipDiv.className = 'relationship-detail';
            
            relationshipDiv.appendChild(document.createTextNode(`${d.label} â†’ [${link.label}] â†’ `));
            
            // Target entity link
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            const targetLink = document.createElement('span');
            targetLink.className = 'relationship-link';
            targetLink.textContent = entities[targetId].label;
            targetLink.onclick = () => {
              const target = nodes.find(n => n.id === targetId);
              if (target) {
                showDetails(null, target);
                highlightConnections(target);
                
                // Highlight in entity list
                document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('selected'));
                const el = document.querySelector(`.entity-item[data-id="${targetId}"]`);
                if (el) {
                  el.classList.add('selected');
                  el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
              }
            };
            
            relationshipDiv.appendChild(targetLink);
            
            // Add description if available
            if (link.properties && link.properties["schema:description"]) {
              const descDiv = document.createElement('div');
              descDiv.style.fontSize = '12px';
              descDiv.style.marginTop = '5px';
              descDiv.textContent = link.properties["schema:description"];
              relationshipDiv.appendChild(descDiv);
            }
            
            outgoingList.appendChild(relationshipDiv);
          });
          
          detailsContent.appendChild(outgoingList);
        }
      } else {
        const noRelationships = document.createElement('div');
        noRelationships.className = 'property-value';
        noRelationships.textContent = 'No connected relationships found.';
        detailsContent.appendChild(noRelationships);
      }
    }
    
    function highlightConnections(d) {
      node.selectAll('circle').attr('r', 8).attr('stroke', null);
      link.attr('stroke', '#999').attr('stroke-width', 1);
      linkText.attr('font-weight', 'normal').attr('fill', '#666');
      
      // Find connected links and nodes
      const nodeId = d.id;
      const connectedLinks = links.filter(l => 
        (typeof l.source === 'object' ? l.source.id === nodeId : l.source === nodeId) || 
        (typeof l.target === 'object' ? l.target.id === nodeId : l.target === nodeId)
      );
      
      const connectedNodes = new Set([nodeId]);
      connectedLinks.forEach(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        connectedNodes.add(sourceId);
        connectedNodes.add(targetId);
      });
      
      // Highlight the node
      node.filter(n => n.id === nodeId)
        .select('circle')
        .attr('r', 12)
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 2);
      
      // Highlight connected nodes
      node.filter(n => connectedNodes.has(n.id) && n.id !== nodeId)
        .select('circle')
        .attr('r', 10)
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 1);
      
      // Highlight links
      link.filter(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        return sourceId === nodeId || targetId === nodeId;
      })
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 2);
      
      // Highlight link text
      linkText.filter(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        return sourceId === nodeId || targetId === nodeId;
      })
        .attr('font-weight', 'bold')
        .attr('fill', '#e91e63');
    }
    
    // Zoom functions
    function zoomIn() {
      if (svg) {
        svg.transition().call(zoom.scaleBy, 1.3);
      }
    }
    
    function zoomOut() {
      if (svg) {
        svg.transition().call(zoom.scaleBy, 0.7);
      }
    }
    
    function resetZoom() {
      if (svg) {
        svg.transition().call(zoom.transform, d3.zoomIdentity);
      }
    }
    
    // Drag functions
    function dragstart(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    
    function dragging(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }
    
    function dragend(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
    
    function exportData() {
      if (!semanticGraph) {
        showStatusMessage("No data to export", "error");
        return;
      }
      
      const dataStr = JSON.stringify(semanticGraph, null, 2);
      const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
      
      const exportFileName = 'semantic-graph-export.json';
      
      const linkElement = document.createElement('a');
      linkElement.setAttribute('href', dataUri);
      linkElement.setAttribute('download', exportFileName);
      linkElement.click();
    }
    
    function showStatusMessage(message, type = 'info') {
      const statusElement = document.getElementById('status-message');
      statusElement.textContent = message;
      statusElement.style.backgroundColor = type === 'error' ? '#f44336' : '#4CAF50';
      statusElement.style.display = 'block';
      
      setTimeout(() => {
        statusElement.style.display = 'none';
      }, 3000);
    }
  </script>
</body>
</html>